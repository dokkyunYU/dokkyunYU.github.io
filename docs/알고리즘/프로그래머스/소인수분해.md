# 소인수분해

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/120852)

## 착안점

소수를 차례대로 찾아서, 해당 소수로 나눠지면 더이상 안나눠질때까지 나누어보는게 좋겠다고 생각했다.

소수를 찾을때는 이전에 찾은 소수 리스트를 불러와서 그 숫자들로 전부 나눠보는 행위를 통해, 해당수가 소수인지 아닌지를 확인한다.

## 코드

```js
function solution(n) {
    function findPrime() {
        let primeNums = [];
        let primeNum = 1;
        function nextPrime() {
            while(++primeNum) {
                let cnt = 0;
                for (const num of primeNums) {
                    if (primeNum % num === 0)
                        break
                    ++cnt;
                }
                if (cnt === primeNums.length) {
                    primeNums.push(primeNum);
                    return primeNum;
                }
            }   
        }
        return nextPrime;
    }
    const answer = [];
    const prime = findPrime()
    while (n > 1) {
        let num = n;
        let pnum = prime()
        if (num % pnum === 0) {
            answer.push(pnum)
            while (Number.isInteger((num /= pnum)))
                n = num;
        }
    }
    return answer;
}
```

## 고찰

closure의 개념을 이해하겠다고 소수찾기 함수를 정의하느라 코드가 길어졌다.
다른 사람들의 풀이를 참고하면 다음과 같은 경우가 많았다.

1. 2부터 시작하여 나누어 떨어지는지 확인하고
2. 만약 나누어 떨어질 경우 정답에 추가하고
3. 더이상 나누어 떨어지지 않을때까지 나눈뒤
4. 숫자를 증가시켜 같은 로직을 반복한다.

예를 든다면 다음과 같은 코드이다.

```js
function solution(n) {
    let answer = []

    let i = 2;
    while (i <= n) {
      if (n % i === 0) {
        answer.push(i)     
        n = n / i
      } else {
      i++        
      }
    }

    return [...new Set(answer.sort((a, b) => a > b ? 1 : -1))]
}
```